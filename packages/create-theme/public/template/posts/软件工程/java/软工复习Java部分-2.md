---
title: 软工复习Java部分-2
date: 2023-12-22 21:25:38
tags:
  - 软工
  - java
---

# 类和对象

面向对象程序（OOP）依照现实世界的实体的特点，把复杂的现实的事物按它们所共有的状态和行为抽象并封装。
面向对象程序语言有三个特征:

- 封装性
- 多态性
- 继承性

对基于“数据”本身，而非“功能”的面向对象程序设计，从抽象的概念上分析所要处理的数据是哪些类(class)，到各类数据可进行的操作方法，都是通过各个封装好的数据模块组合起来解决问题。

一个数据模块称为一个对象(object)，它是抽象出来的某个类(class)的一个实例。类就是一个引用数据类型，对象则是这个引用数据类型的变量。对象就是经过实例化的实体的引用。

- **类的变量描述对象的属性，类的方法体现对象的行为**。封装在类中的这些数据的变量和方法，为对象的创建提供了模板。
- **对象之间的交互作用是通过对象的消息机制实现的**。所谓消息是对象对其他或者自身方法的访问，一个消息的产生就是一个对象方法的调用。
- 类和对象是面向对象程序设计中的基本概念，也是编程方法的基础。类就是Java的执行单位。Java运行的就是Java类本身。

**对象**

- 对象是现实世界事物的模型化。**用变量来表示状态，用方法来实现行为。**
- 对象的变量组成了对象的中心或核，而方法是围绕在变量四周的。
- 封装：某一对象的变量对程序中的其它的对象而言是隐藏的，它是在这个对象方法的保护监理之下

**消息**

消息是软件对象之间相互作用和互相联系。

对象的行为由方法来实现，消息传递是对象之间进行交互的主要方式。

消息由三个部分组成：

- 接收消息的对象(目标对象)
- 接收者采用的方法(目标方法)
- 方法所需传递的参数。

**类**

类定义了对象的类型。包括对象内部的数据，它是对象的特性，和对象对自己的数据上的操作功能。因此类就是对象的模板。

- 类是某种对象共有的状态和行为的原型。
- 一个类可以有许多的对象，每一个对象都是这个类的一个实例，它们也就都具有相同的特征。

## 类的创建

类是Java语言的最基本概念，组成Java程序的基本要素。类是Java的执行单位，Java运行的就是Java类本身。它封装了该类对象的变量和方法。

一个类包括有三个部分：

- 类声明
- 类成员
- 类的构造器(方法)

```
classDeclaration{
	classBody
}
```

一般声明形式

```
[public] class <clsName> extends <supCls> implements <intf> {
	<classBody>
}
```

- `class`是表示创建类的关键字
- `<clsName>`是Java合法标识符
- `[public]`是可选项，表示该类是`public`类；类的可选项还有`abstract`、`final`等等
- `extends <superCls>`则是继承性表示，该类继承了类`<superCls>`
- `implements <intf>`则是对接口实现表示，该类实现了接口`<intf>`

### 类体定义

类的体包含有：

- **成员变量**。在类中创建的变量，表示对象属性；
- **成员方法**。类的方法表示对象的行为或能力；
- **类的构造器(方法)**。为创建类的实例所使用。

一般格式

```
classDeclaration{
	memberVariableDeclaration
	memberMethodDeclaration
	classStructorDeclaration
}
```

### 成员变量

- 在类中创建的变量，表示对象属性
- **作用域在类中是全局的**，能被类中所有方法所访问
- 在创建时有初始化值。
- `<type> variableList = initialValue;`
  例： `int a, b; // 成员变量a和b都有一个初始值为0`

成员变量的定义还有许多可加的修饰符，用于声明成员变量的访问控制权限和使用限制。

- 访问控制权限的修饰符有`public`、`protected`、`private`等
- 使用限制的修饰符有`final`、`static`、`transient`、`volatile`等

#### 初始化

- 创建的变量时初始化值。创建时分配存储空间赋上缺省的初值。

  例：` int a, b; // 成员变量a和b都有一个初始值为0`

  ![](https://pic.imgdb.cn/item/6585980ec458853aefdbbd10.jpg)

- 创建时赋初值；

  例：` int x = 10, y = 20; // x,y分别赋初值10,20`

- 在类的构造器中对成员变量的赋初值。

  ```
  Point(){
  	x = 10; // x赋初值10
  	y = 20; // y赋初值20
  }
  ```

#### 常量

使用修饰符`final`修饰的变量就像常量一样地使用，称其为常量符号。

常量符号数据**只能读取，不能改变**。通常常量符号标识符全用大写字母，单词间用“_”分隔。

```
final int MAX_MONTH = 12;
final int MAX_DAY = 31;
final int MAX_WEEK = 7;
```

### 成员方法

方法的创建分为二个部分，一个是方法声明，另一个是方法体。

```
methodDeclaration{
	methodBody
}
```

声明格式：

```
[accessControl] returnType methodName(paraList)
```

- `[accessControl]`是可选项，为访问控制修饰符，限定访问权限.
- `returnType`是方法返回数据类型，它表示方法返回时返回数据的类型.
- `methodName`是方法名，它是Java合法标识符.
- `paraList`是方法参数列表，表示方法调用时所带参数。称为形式参数。

方法体格式：语句及语句块组成，包含：

- 局部变量声明
- 流程控制语句
- 语句块
- return语句*

- 当方法返回类型不是void时，方法中必须有带表达式return语句：

​	`return expression;`

- 当方法返回类型是void时，方法中可以有return语句，但是不能带表达式：
  `return;`

方法调用时的参数传递

- 方法在被调用时，其参数的数据传递是值传递，即实际参数传值给形式参数。

- 形式参数是简单类型

  在方法调用时，实际参数将其存储单元的数据赋值给形式参数

- 形式参数是引用类型
  在方法中，引用类型的参数没有发生引用的改变，则**形式参数对引用中的变量值改变自然会影响到实际参数引用中变量的值**

```
Point pi=new Point(1,2)；
void setRefer1(Point p){
	p.x = 10;
	p.y = 20;
}
setRefer1(pi)
```

参数p是**引用类型**，其成员的x,y值发生改变，**会影响调用的实参**，即函数结束后成员x和y的值改变。

## 方法过载

在同一个类中创建的具有相同方法名，但是参数不同的方法。

- 参数不同：
- 数量不同；
- 数量相同，但是对应的类型不同。

方法过载也是多态性表现之一。方法过载中的方法**由调用时的实参决定**调用的方法是那个，过载的方法都必须采取独一无二的自变量类型列表。

## 类的构造

每一类都有自己的构造方法，或者称为类的构造器。构造方法是用来创建一个类的实例的。

- 构造方法是用类名作构造方法名
- 构造方法具有参数和语句体，但没有返回类型的声明。如果有返回类型声明，则此方法就再不是构造方法，而成为一个一般的成员方法
- 构造方法**不是类的成员方法**，所以不能用对象调用它。
- 构造方法的调用是由new运算符实现
- 构造方法返回的是这个类的实例的引用
- 构造方法中的语句实现对成员变量的初始化；
- 构造方法的方法过载。一个类可以有多个构造方法；
- 构造方法之间通过`this()`形式相互调用。

#### 方法

类的构造方法又可以分为两种

- 默认构造方法

  默认构造方法是指**不带参数的构造方法**，该方法可以有语句，也可以没有语句

- 非默认构造方法

​	非默认构造方法是指**带参数的构造方法**。

类创建时没有创建构造器，则在编译时编译器自动为该类添加一个默认构造器，即没有创建构造器的类可以直接使用默认构造器。

类创建时如果有任何构造器被创建，则在编译时编译器不再为该类创建默认构造器。即创建了构造方法的类，不再自动有一个默认的构造方法，或者说默认构造器失效，除非也创建一个不带参数的构造器。

## 类成员和实例成员

### `static`

一旦将成员设为static，数据或方法就不会同那个类的任何对象实例联系到一起。

- 即使从未创建那个类的一个对象，仍能调用一个static方法，或访问一些static数据
- 由于static 方法不需要创建任何对象，所以它们不可简单地调用其他那些成员变量

声明为static的方法有以下几条限制：

- 它们仅能调用其他的static方法。
- 它们只能访问static数据。
- 它们不能以任何方式引用this或super

> static块*
>
> - 如果你需要通过计算来初始化你的static变量，你可以声明一个static块
> - static块仅**在该类被加载时**执行一次

### 类成员

- **有`static`修饰的成员**，也可以称为静态成员；

  例：`static int a;`

- 类成员：可以用类名直接访问：

  `<类名>·<成员名>`

  例：`Point.a = 10;`

- 类成员也可以用对象名来访问，但是**所该类的所有对象都共享类成员变量**。

  ```
  Point p = new Point();
  Point.a = 10;
  p.a = 100;
  ```

- 类成员提供了事实上的全局变量和全局方法

### 实例成员

**通过创建实例才能访问和使用**的成员。

- 创建对象，由对象访问。例：`p.x = 10;`

- 定义时无`static`修饰的成员；
  例：

  ```
  class Point{
  	int x, y; // x,y为实例成员变量
  }
  ```

- 实例成员**不能用类名直接访问**。

  例：`Point.x `访问是不合法的。

## 对象创建与使用

- 对象：是一个变量，它的存储开销是一个地址存储单元。

- 实例：是在存储空间分配的存储堆。是垃圾回收的目标。

- 引用：对象通过它存储的实例的起始地址对实例实现访问。

对象的生命周期：创建、使用和销毁三个阶段。

- 创建：分两步。

  - 声明：

    `Point p;`

  - 实例化：

    通过`new`运算符调用构造器，通过赋值=对这个实例引用。
    `p = new Point();`

- 对象使用

  - 通过对象名对成员的访问：

    `<对象名>·<成员>`

    ```
    p.x = 100;
    int temp = p.getData();
    ```

- 销毁：

  - 垃圾回收：实例开销的回收。

    - 由JVM自动完成。

    - 调用`finalize()`方法处理。

      Java在对象作为垃圾被收集前，自动调用对象从`Object`类继承来的`finalize()`方法，清除自己所占用的资源。该方法声明的格式以下：

      ```
      protected void finalize() throws throwable{
      	... //clean up code for this class
      	super.finalize();
      }	
      ```


## 类的继承

类继承另一个类，这个类除了创建自己的成员外，还能够继承或扩展另一个类的成员。

**被继承的类叫超类（superclass），继承超类的类叫子类（subclass）**

### 继承的特性

- 单一继承性：子类只能有一个超类，而超类可以有多个子类
- 子类继承超类的所有成员
- 子类可以创建自己的成员；
- **子类不能继承超类的构造器，只能在构造器中通super()调用超类的构造器；**
- 子类的构造器首先要调用超类的构造器；
- 多态性之一：子类的成员隐藏和覆盖超类中相同的成员；
- 多态性之二：超类的对象可以对子类的实例引用；
- 由abstract和final修饰的类指示类的是否必须或不能被继承。

创建子类的格式如下：

```
[abstract|final] class SubCls extends SupCls{
	SubClassBody
}
```

- `abstract`是可选项，修饰的类叫抽象类，指示**其对象引用的必须是其子类实例**
- `final`是可选项，修饰的类叫终结类，指示其不能被继承，不能有子类
- `SubCls`是创建的类，称为子类
- `extends`是关键字，指示两个类存在的继承关系
- `SuperCls`是`SubCls`类的超类

在创建类时，若缺省extends，则该类就为Object类的直接子类。Object类是Java语言中所有类的直接或间接超类。Object类存放在`java.lang`包中。

- 子类继承了超类的所有成员，但是无法访问某些受限的成员
- 子类中可以访问从超类继承下来的三种访问权限设定的成员
  - `public`：所有类都可以访问
  - `protected`：自身及所有子类可以访问
  - `private`：只有自身可以访问
  - 缺省（为`Default`属性）

在超类中，由private修饰的访问权限的成员变量和方法，虽然被子类继承，但是子类不能访问。

## 成员变量的隐藏和方法覆盖

- 在子类的创建中，如果出现了与其超类中相同的成员变量，则超类中的成员变量被子类中的成员变量所隐藏。

- 如果出现了与超类中有相同名、同参数及同返回类型的成员方法， 则超类中的成员方法被子类中的成员方法所覆盖。

也就是子类中出现了与超类中相同的成员，则超类的成员会被子类覆盖。

### 方法覆盖与运行时的多态

方法覆盖：

- 在子类的创建中，具有与超类中有相同的方法名、相同的参数以及相同的返回数据类型。

- 它还具有比超类中被覆盖方法更大的可访问性，即权限限制更宽松。

  public > protected > 缺省 > private

  ![](https://pic.imgdb.cn/item/6586aaaac458853aef254f47.jpg)

- 不同于方法过载。方法过载是在一个类中具有相同方法名的方法，它们之间有不同的参数。

## `null, this, super`

### `null`

`null`表示变量的值为“空”，用于表示对象或数组还没有相应的实例引用。例如：

### `this`

- 表示对类的实例访问，它也表示了对象对该实例引用访问

- 在类中可以来指向成员变量，以示区别于非成员变量
- 在构造器中，使用`this()`形式对另一个构造器的调用
- 在类的创建中，需要表示对自身的实例访问时，用`this`表示

### `super`

在子类中，使用super访问**被隐藏**的超类变量，**被覆盖**的超类方法。

使用有三种情况：

- 访问被隐藏的超类成员变量：super.varName

- 调用超类中被覆盖的方法：

  `super.methodName([paramList])`

- 调用超类中的构造方法：` super([paramList])`

#### 调用时机

- `super( )`**必须是子类构造函数的第一个执行语句**，无论你用到了`super( )`没有，这个次序不变。
- 如果super( )没有被用到，每个超类的默认的或无参数的构造函数将执行。

![](https://pic.imgdb.cn/item/6586c577c458853aef83c982.jpg)

## 运行时的多态

- 超类的对象可以引用子类的实例
- 该对象仍然只能够调用超类中定义的方法和变量
- 对于覆盖或继承的方法，Java运行时系统根据调用该方法的实例的类型来决定选择哪个方法调用
- 对子类的一个实例，如果子类覆盖了超类的方法，则运行时系统调用子类的方法
- 如果子类继承了超类的方法（未覆盖），则运行时系统调用超类的方法

![](https://pic.imgdb.cn/item/6586c710c458853aef89f017.jpg)

### 方法覆盖与运行时多态

```
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world!");
        people p = new me();
        p.sayHello();
    }
}

class people {
    public void sayHello() {
        System.out.printf("Hello!");
    }
}

class me extends people{
    me() {
        System.out.printf("hello\n");
    }
    void meHello() {
        System.out.printf("Hello!");
    }
    public void sayHello() {
        System.out.printf("I say Hello!");
    }
}
```

![](https://pic.imgdb.cn/item/6586c832c458853aef8e4bcb.jpg)

- 当超类的对象对子类实例引用时，这个对象所访问的成员必须是超类中所具有的。
- 这个对象不能访问子类自己创建的成员。
- 当这个对象访问的是被覆盖的方法，则调用的是子类中覆盖方法。
- 只有当这个对象被强制转换成子类类型时，这个子类的所有成员才有可能被访问。

## `final`和`abstract`

### `final`

`final type identifier=[初值]`

许多程序设计语言都有自己的办法告诉编译器某个数据是“常数”。常数主要应用于下述两个方面：

- 编译期常数，它永远不会改变
- 在运行期初始化的一个值，我们不希望它发生变化

对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。

- 空白`final`

  一个变量或者一个引用通过final修饰，但却没有进行初始化，必须在构造方法中进行初始化，并且只能出现一个构造方法。

  - 尽管被声明成final，但却未得到一个初始值。
  - 空白final必须在实际使用前得到正确的初始化。
  - 空白final具有最大的灵活性:
  - 位于类内部的一个final 字段现在对每个对象都可以有所不同，同时依然保持其“不变”的本质。

将参数设成final属性，方法是在参数列表中对它们进行适当的声明。在一个方法的内部，不能改变该final参数。

由final修饰的类称终结类，不能被继承。由于安全性的原因或者是面向对象设计的考虑，限定一些类不能被继承。

- `final`类不能被继承，保证了该类的唯一性。
- 对于一个类的定义已经很完善，不需再创建它的子类，也可以将其修饰为`final`类。

#### `final `方法

以`final`修饰的方法是不能被子类的方法所覆盖。

其格式为：

```
final returnType methodName([paraList]){
	...
}
```

可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。编译器就可为final 方法调用生成效率更高的代码。

### `abstract`

当一个类的定义完全表示抽象概念时，它不需要（也不应该）被实例化为一个对象。

- 抽象类本身存在未实现的方法（abstract方法），这些方法不具备实际功能，它只能衍生出子类，**抽象方法则由衍生子类时所覆盖**。
- **`abstract`方法必须是在`abstract`类中，但是`abstract`类中也可以有非abstract方法。**

格式：

```
abstract class abstractClassName{
	...
}
```

`abstract`方法格式：

```
abstract returnType methodName([paraList]);
```

- `abstract`方法是没有语句实现部分，直接由;结束。
- `abstract`方法必须是在`abstract`类中，并由其子类的方法覆盖。

在创建抽象方法时，要注意有下面三种方法不能作为抽象方法定义：

- 构造方法
- 类方法（`static`）
- 私有方法

## `Object`类

- `Object`类处于Java开发环境的类层次树的根部，处于Java类层的最高层的一个类，是所有类的超类。
- 其它所有的类都直接或间接地为它的子类。
- 该类定义了一些所有对象的最基本的状态和行为，包括与同类对象相比较，转化为字符串等

![](https://pic.imgdb.cn/item/6586d308c458853aefba08f3.jpg)

