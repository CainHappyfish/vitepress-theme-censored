# 操作系统期中复习

## ⬅️操作系统概论

### 操作系统的目标和作用

**目标**

- **方便性** 操作系统使计算机更易于使用。
- **有效性** 操作系统允许以更有效的方式使用计算机系统资源。
  - 提高系统**资源利用率**
  - 提高系统的**吞吐量**
- **可扩展性** 在操作系统中 允许有效地 开发、测试和引进新的系统功能。
- **开放性** 实现应用程序的可移植性和互操作性 要求具有统一的开放的环境。

**作用**

- 作为用户与计算机硬件系统之间的接口
- 作为计算机系统**资源的管理者**（软件和硬件资源）
- 用作扩充机器

**单道批处理系统：**系统对作业的处理都是成批进行的，且在**内存中始终仅存一道作业运行**，运行结束或出错，才自动调另一道作业运行，故称为单道批处理系统

**多道批处理系统：**在内存中存放多道作业运行，运行结束或出错，自动调度内存中的另一道作业运行。

好处：

- 提高 CPU 的利用率
- 提高内存和 I/O 设备利用率
- 增加系统吞吐率

### 操作系统的基本特征

- **并发性**：**最重要的特征**，**其它特征都以并发为前提**。

  - 并发：并行性和并发性，并发执行的过程。

    - 并行性：是指两个或多个事件在 **同一时刻** 发生。

    - 并发性：是指两个或多个事件在 **同一时间间隔内** 发生。

  - 任务共行

    - 从宏观上看，任务共行是指系统中有多个任务同时运行

    - 从微观上看，任务共行是指单处理机系统中的任务并发（Task Concurrency ：即多个任务在单个处理机上交替运行） 或多处理机系统中的任务并行（ Task Parallelism即多个任务在多个处理机上同时运行） 。

  - 进程

    - 程序：静态实体
    - 进程：**系统中能独立运行并作为资源分配的基本单位**，由一组机器指令、数据和堆栈等组成的独立运行的活动实体 。

  - 线程

    作为**独立运行和调度的基本单位**。

- **共享性**

  是指系统中的资源可供内存中多个 **并发执行** 的进程共同使用。

  - 互斥共享

    - 临界资源：一段时间内只允许一个进程访问的资源

    系统中的临界资源可以提供给多个进程使用，但**一段时间内仅允许一个进程使用**，称为 互斥共享方式。

  - 同时访问

    - 从宏观上看，资源共享是指**多个任务可以同时使用系统中的软硬件资源**。
    - 从微观上看，**多个进程交替互斥地使用系统中的某个资源**。

​	**并发和共享是操作系统的两个最基本的特征，它们又是互为存在的条件。**

- **虚拟性**

  指通过某种技术把一个物理实体变为（映射为）若干个逻辑上的对应物。

  - 时分复用技术：虚拟处理机、虚拟设备
  - 空分复用技术：虚拟磁盘技术、虚拟存储器

- **异步性**

  多道程序环境下程序（进程）以异步的方式执行，每道程序在何时执行、各自执行的顺序是什么、 完成时间的长短等都是不确定的，也是不可预知的。

### 操作系统的主要功能

操作系统的主要任务：

为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行， 并且能 最大程度地提高系统中各种资源的利用率和方便用户的使用。

**操作系统应具有五个方面 功能**

- 处理机管理（CPU）
- 存储器管理
- 设备管理
- 文件管理
- 方便用户使用的用户接口。

## 🚓 进程管理

### 前趋图和程序执行

**前趋图：**有向无环图，用于描述进程之间执行的前后关系，也可以表示为二元关系$<P, \rightarrow>$

![](https://pic.imgdb.cn/item/661e694f0ea9cb140393ba6b.png)

P={P1，P2，P3，P4，P5，P6，P7，P8，P9 }
→= { (P1，P2), (P1，P3), (P1，P4 ),(P2，P5 ), (P3，P5 ), (P4，P6 ), (P4，P7 ), (P5，P8 ), (P6，P8 ), (P7，P9 ),(P8，P9 )｝

#### 程序的顺序执行及其特征

- **顺序性** ：处理机的操作严格按照程序所规定的顺序执行 
- **封闭性** ：程序运行时独占全机资源程序一旦开始执行其执行结果不受外界因素影响 
- **可再现性** ：只要程序执行时的环境和初始条件相同都将获得相同的结果

#### 程序的并发执行及其特征

- **间断性** ：由于它们共享系统资源以及为完成同一项任务而相互合作致使在这些并发执行的程序之间形成了相互制约的关系。相互制约将导致并发程序具有执行暂停执行这种间断性的活动规律。
- **失去封闭性**： 是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变 致使程序的运行已失去了封闭性 。
- **不可再现性** ：程序在并发执行时由于失去了封闭性导致不可再现性

### 进程的描述

#### 进程的特征与状态

典型的进程定义有：

- 进程是程序的一次**执行** 
- 进程是一个程序及其数据在处理机上顺序执行时所发生的**活动** 
- 进程是程序在一个数据集合上运行的 **过程** ，它是系统进行资源分配和调度的一个独立单位 

**进程的特征**

- **结构特征**
  - 为使程序 含数据 能独立运行 应为之配置一个**进程控制块，即 PCB(Process Control Block)**
  - 而由**程序段 、 数据段和PCB**三部分便构成了**进程实体** 
  - 所谓创建进程实质上是创建进程实体中的PCB；而撤消进程实质上是撤消进程的 PCB 
- **动态性**
  - 进程的实质是进程实体的一次**执行过程**，因此动态性是进程的最基本的特征 
  - 动态性表现： 它**由创建而产生，由调度而执行，由撤消而消亡**。可见进程实体有一定的**生命期**。
  - **程序**是一组有序指令的集合，其本身并不具有运动的含义，因而是**静态**的 。

- **并发性**：这是指多个进程实体同存于内存中，且能在一段时间内同时运行 
- **独立性**：指进程实体是一个能独立运行 、 独立分配资源和独立接受调度的基本单位
- **异步性**：指进程按各自独立的 、 不可预知的速度向前推进或说进程实体按 **异步** 方式运行 

#### 进程的基本状态及转换

**进程的三状态**

![](https://pic.imgdb.cn/item/661e6cff0ea9cb14039d8fdc.png)

- **就绪状态**：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。
- **执行状态**：进程已获得CPU，其程序正在执行
- **阻塞状态**（blocked）：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态，有时也称为等待状态。

**进程的五状态**

![](https://pic.imgdb.cn/item/661e6dcb0ea9cb14039f86cb.png)

> 图是那样画，但任何状态都可以退出

- **Ready** 准备执行
- **Running** 占用处理机（单处理机环境中，某一时刻仅一个进程占用处理机）
- **Blocked** 等待某事件发生才能执行 如等待 I/O 完成等
- **New** 进程已经创建 但未被 OS 接纳为可执行进程，并且程序还在辅存，PCB 在内存
- **Exit** 因停止或取消，被 OS 从执行状态释放

![](https://pic.imgdb.cn/item/661e6e460ea9cb1403a0a54a.png)

**两种模式的阻塞、就绪队列**

- 单阻塞队列、单就绪队列

  ![](https://pic.imgdb.cn/item/661fcbb10ea9cb1403bdb9d9.png)

- 多阻塞队列、单就绪队列

  ![](https://pic.imgdb.cn/item/661fcbc20ea9cb1403be8e33.png)

**状态转换**

1. 空 → 创建状态

   新创建的进程首先处于创建状态。

2. 创建状态 → 就绪状态 

   当系统允许增加就绪进程时，操作系统接纳创建状态进程，将它变为就绪状态，**插入就绪队列中**。

3. 就绪状态 → 执行状态 

   **当处理机空闲时，将从就绪队列中选择一个进程执行，该选择过程称为进程调度**。将处理机分派给一个进程，该进程状态从就绪转变为执行。

4. 执行状态 → 终止状态 

   执行状态的进程**执行完毕** ，或出现诸如访问地址越界、非法指令等**错误** ，而被异常结束，则进程从执行状态转换为终止状态。

5. 执行状态 → 就绪状态 

   分时系统中，时间片用完，或优先级高的进程到来， 将暂停较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度。

6. 执行状态 → 阻塞状态 

   执行进程需要等待某事件发生。通常，会因为进程需要的系统调用不能立即完成，如读文件、共享虚拟内存、等待 I/O 操作、等待另一进程与之通信等事件而阻塞。

7.  阻塞状态 → 就绪状态 

   当阻塞进程等待的事件发生，就转换为就绪状态。进入就绪队列排队，等待被调度执行。

#### **多个进程竞争内存资源**

- 内存资源紧张
- 无就绪进程，处理机空闲：I/O 的速度比处理机的速度慢得多，可能出现全部进程阻塞等待 I/O

**解决方法**：

- 对换技术，交换技术 Swapping

  将内存中暂时不能运行的进程，或暂时不用的数据和程序，**换出到外存**，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的数据和程序， **换入内存**。进程被交换到外存，状态变为 **挂起状态**

- 虚拟存储技术（将在第 4 章讲述）

**挂起(Suspend)**：将内存中处于阻塞、就绪、甚至是执行状态的进程放到外存，不再参与CPU的竞争，这种静止状态称为挂起状态

- 被挂起的原因

  - 终端用户的请求，如调试
  - 父进程请求
  - 负荷调节的需要。当实时系统中的工作负荷较重,把一些不重要的进程挂起以保证系统能正常运行。
  - 操作系统的需要。操作系统有时希望挂起某些进程以便检查运行中的资源使用情况或进行记账。

  > PS 计院：
  >
  > - 进程全部阻塞，处理机空闲
  > - 交换，如系统负荷过重，内存空间紧张
  > - 操作系统的需要，操作系统可能需要挂起后台进程或一些服务进程，或某些可能导致系统故障的进程。

**激活(Activate/Resume)**：把一个进程从外存转到内存

> 挂起条件独立于阻塞条件

#### **阻塞与挂起的组合**

进程是否**等待特定事件**，阻塞与否；进程是否**被换出内存**，挂起与否

- **阻塞且在内存：**进程在内存，等待某事件的发生
- **就绪且在内存：**进程在内存，且可被调度执行
- **阻塞** **且** **挂起（Blocked, suspend）**：进程**在外存**并**等待特定事件**的出现；
- **就绪** **且** **挂起（Ready, suspend）**：进程**在外存**，但只要进入内存，即可运行；

单挂起：

![](https://pic.imgdb.cn/item/661e73b90ea9cb1403ad36d4.png)

![](https://pic.imgdb.cn/item/661e73fd0ea9cb1403adec42.png)

双挂起：

![](https://pic.imgdb.cn/item/661e742c0ea9cb1403ae6614.png)

![](https://pic.imgdb.cn/item/661e72920ea9cb1403aa703f.png)

#### 进程管理中的数据结构

![](https://pic.imgdb.cn/item/661e74be0ea9cb1403afe465.png)

#### **进程控制块的作用**

- 进程存在的唯一标志
- PCB常驻内存

#### **进程控制块中的信息**

- **进程标识符**

  进程标识符用于惟一地标识一个进程。一个进程通常有两种标识符：

  - **内部标识符**：为每一个进程赋予一个**惟一的数字标识符**。设置内部标识符主要是为了方便系统使用
  - **外部标识符**：它由创建者提供，通常是**由字母 、 数字组成**。往往是由用户（进程）在访问该进程时使用
  - 内部标识符 PID
  - 父进程标识符 PPID
  - 用户标识符 UID

- **处理机状态**

  处理机状态信息主要是由处理机的各种寄存器中的内容组成：

  - 通用寄存器 Ri
  - 指令计数器 PC
  - 程序状态字 PSW
  - 用户栈指针 SP

- **进程调度信息**

  在PCB中还存放一些与进程调度和进程对换有关的信息，包括：

  - 进程状态
  - 进程优先级
  - 进程调度所需的其它信息
  - 事件，阻塞原因

- **进程控制信息**

  - 程序和数据的地址
  - 进程同步和通信机制
  - 资源清单
  - 链接指针

**PCB的组织方式**

- 线性方式：将系统中的所有PCB 组织在一张线性表中 将该表的首地址存放在一个专用区域中

  ![](https://pic.imgdb.cn/item/661e775f0ea9cb1403bf7050.png)

- 链接方式

  ![](https://pic.imgdb.cn/item/661e77d50ea9cb1403c3a367.png)

  ![](https://pic.imgdb.cn/item/661e78060ea9cb1403c546b1.png)

- 索引方式

  ![](https://pic.imgdb.cn/item/661e78260ea9cb1403c65c46.png)

### 进程控制

进程控制是用于创建一个新进程，终止一个已完成的进程，或去终止一个因出现某事件而使其无法运行下去的进程，还负责进程运行中的状态转换。
进程控制一般是由 OS 的内核中的原语（primitive）来实现的。

#### 操作系统内核

- 操作系统中包含重要系统功能的部分。
- 常驻内存，便于提高操作系统运行效能。

##### 定义

一些与硬件紧密相关的模块或运行频率较高的模块，公用基本操作模块等常驻内存，便于提高操作系统运行效能的软件，称为操作系统的内核。

- 与硬件紧密相关的模块（中断处理）

- 常用设备驱动、运行频率高的模块（时钟管理、进程调度）

  目的：

  1. 保护
  2.  提高 OS 效率

##### 功能

- 资源管理功能
  - 进程管理：创建、撤消、调度、控制
  - 存储管理：分配或回收空间、虚拟存储管理等。
  - I/O设备管理：设备、通道的分配和回收、设备的管理、虚拟设备的实现等。
- 支撑功能
  - 中断处理：
    - 中断处理既是内核的基本功能，也是整个操作系统赖以活动的基础，操作系统的一切重要活动最终都依赖于中断
  - 时钟管理
    - 操作系统的很多功能都依赖于时钟，如时间片控制等。
  - 原语操作
  - 记账（统计、监测）功能

#### 进程的创建

**进程的层次结构**

- **父进程**：创建另一个新进程的进程

- **子进程**：父进程创建的新进程，可以继承父进程所拥有的资源

**进程图**

- 进程图是用于描述一个进程的家族关系的有向树。
- 子进程可以继承父进程所拥有的资源。
- 当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。
- 在撤消父进程时，也必须同时撤消其所有的子进程。

**进程创建**

> 导致一个进程去创建另一个进程的典型事件有以下四类：
>
> - 用户登录
> - 作业调度
> - 提供服务
> - 应用请求

调用进程创建原语 Creat 按下述步骤创建一个新进程：

1. 申请空白 PCB。
2.  为新进程分配资源。
3.  初始化进程控制块，包括：
   1. 初始化标识信息 
   2. 初始化处理机状态信息 
   3. 初始化处理机控制信息 
4. 将新进程插入就绪队列。

#### **进程终止**

- **正常结束**：批处理中用Halt指令，分时中用 Logs off 指令

- **异常错误**

  - 越界错误：存储区 。
  - 保护错：写一个只读文件 。
  - 非法指令：执行一条不存在的指令 。
  - 特权指令错：用户访问只允许 OS 执行的指令 。
  - 运行超时
  - 等待超时
  - 算术运算错：被 0 除 
  - I/O 故障

- **外界干预**

  外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。

  - 操作员或操作系统干预
  - 父进程请求终止该进程
  - 当父进程终止时，OS 也将他的所有子孙进程终止

**进程终止过程**

1. 根据被终止进程的标识符 ID ，从 PCB 集合中检索出该进程的 PCB ，从中读出该进程的状态
2. 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度
3. 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程
4. 将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统
5. 将被终止进程（它的 PCB ）从所在队列（或链表）中移出，等待其他程序来搜集信息

#### 进程的阻塞与唤醒

**引起进程阻塞的事件**

- **请求系统服务**：提出 I/O 服务时 并不立即满足该进程的要求时，转变为阻塞状态来等待
- **启动某种操作**：当进程启动某种操作后 在该操作完成之后才能继续执行 。
- **新数据尚未到达**：对于相互合作的进程而言 。
- **无新工作可做**：如发送进程。

**进程的阻塞过程**

- 正在执行的进程，当发现上述某事件时由于无法继续执行，于是进程便通过调用阻塞原语` block()`把自己阻塞 。
- 把 进程控制块中的现行状态由 执行 改为 阻塞并将 PCB 插入阻塞队列 。
- 转调度程序进行重新调度 将处理机分配给另一就绪进程并进行切换 。

**阻塞进程的唤醒**

当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放 了 I/O 设备的进程）调用唤醒原语`wakeup()`将等待该事件的进程唤醒。

**进程唤醒过程**

- 首先把被阻塞的进程从等待该事件的阻塞队列中移出 将其 PCB 中的现行状态由阻塞改为就绪
- 然后再将该 PCB 插入到就绪队列中 。

#### 进程的挂起与激活

**进程的挂起**

当出现了引起进程挂起的事件时，系统将利用挂起原语`suspend() `将指定进程进程挂起。
挂起原语的执行过程是：

- 首先检查被挂起进程的状态，若处于 **活动就绪** 状态，便将其改为 **静止就绪**
- 对于 **活动阻塞** 状态的进程，则将之改为 **静止阻塞** 状态。

**进程的激活**

- 当发生激活进程的事件时 则可将在外存上处于静止就绪状态的进程换入内存 。
- 系统利用激活原语` active()`将指定进程激活
  - 激活原语先将进程从外存调入内存 检查该进程的现行状态
  - 若是 **静止就绪** 便将之改为 活动就绪 ；若为 **静止阻塞**便将之改为 **活动阻塞** 。

### 进程同步

#### **进行进程同步的原因**

- 由于进程的异步性，也会给系统造成混乱，在OS 中引入进程同步。
- **进程同步的主要任务** ：是使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。

#### 进程同步的基本概念

- **间接**相互制约关系

  由于资源共享，例如多进程同时访问一个I/O设备 。

- **直接**相互制约关系

  主要由于进程间的合作，如父子进程协作完成一个操作 。

- **临界资源**

  一次仅允许一个进程访问的资源

- **临界区**

  把在每个进程中访问**临界资源**的那段代码称为**临界区**

  访问临界资源的描述：

  - 进入区：检查有无进程进入
  - 临界区：
  - 退出区：将访问标志复位

  ```
  while (TRUE) {
      Entry section
      Critical section
      Exit section
  }
  ```

- **同步机制应遵循的规则**

  - **空闲让进**
  - **忙则等待**
  - **有限等待**
  - **让权等待**

#### 硬件同步机制

利用计算机硬件指令解决临界区问题

- 对临界区管理将标识看做一个锁，“锁开”进入，“锁关”等待。
- 初始打开，每个进入临界区的进程必须对锁进行测试。
- 测试和关锁操作必须连续（原子操作）

**关中断**

进入锁测试前关闭中断，完成锁测试并上锁后打开中断进程在临界区时计算机系统不响应中断，不会引发调度。
缺点：

- 滥用关中断会引发严重后果
- 关中断时间过长会影响系统效率
- 不适用于多CPU系统

**硬件指令Test-and-Set**

```
boolen TS( boolen *lock )
    boolean old;
    old = *lock;
    *lock =TURE;
    return old;
}

do{
	…
    while TS( &lock);
    critical section;
    lock :=FALSE;
    remainder section;
}while(TRUE);
```

**swap：交换两个字的内容**

```
void swap(boolen *a, boolen *b) {
    boolean temp;
    temp = *a;
    *a =*b;
    *b=temp;
}

do{
	key=TURE;
    do{
    	swap(&lock,&key);
    } while(key!=FALSE);
    
    临界区操作
    
    lock = FALSE;
    …
}while(TRUE);
```

#### 信号量机制

- **整型信号量**

  定义为一个整型量仅能通过两个标准的原子操作` wait(S) `和` signal(S) `来访问。又称为 P 、 V 操作。

  ```
  wait(S):
      while S <= 0 do no-op
      S := S - 1
  signal(S):
  	S := S + 1
  ```

  整型信号量机制的问题： 忙等 。

  - wait 操作中信号量 S<=0 时，会不停的测试
  - 未遵循 让权等待 的原则

- **记录型信号量**

  记录型信号量机制是一种不存在“忙等现象的进程同步机制。

  记录型信号量的数据结构

  ```
  type struct {
      int value;
      struct process_control_block *list;
  } semaphore;
  ```

  记录型信号量的` wait `和` signal `操作

  ```
  wait (semaphore *S) {
      S->value := S->value - 1;
      if (S->value < 0）
      then
      	block(S->list); 	// 调用 block 原语自我阻塞，放弃处理机
  }
  
  signal(semaphore *S) { 
      S->value := S->value + 1；
      if (S->value <= 0）
      	wakeup(S->list);				// 唤醒阻塞链表中第一个等待进程
  }
  ```

  - `s.value > 0 `，表示还可执行`wait(s)`而不会阻塞的进程数（可用资源数）。

    每执行一次`wait(s)`操作，就意味着请求分配一个单位的资源

  - `s.value ≤ 0 `，表示已无资源可用，因此请求该资源的进程被阻塞。

    - 此时，`s.value`的绝对值等于该信号量阻塞队列中的等待进程数。

    - 执行一次`signal`操作，就意味着释放一个单位的资源。

  - `s.value< 0`，表示`s.L`队列中还有被阻塞的进程，` signal(s)`原语需要唤醒该队列中的第一个进程，将它转移到就绪队列中。 

  **整型信号量与记录型信号量的问题：只能用于共享一个临界资源**

  进程 A 和进程 B 按照下述次序交替执行` wait `操作：

  ```
  processA
  	wait( Dmutex ); // Dmutex = 0
  processB
  	wait( Emutex ); // Emutex = 0
  processA
  	wait( Emutex ); // Emutex = -1 A 阻塞
  processB
  	wait( Dmutex ); // Dmutex = -1 B 阻塞
  ```

- AND型信号量

  - AND 同步机制的基本思想

    将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。

  - **原子操作：要么全部分配到进程，要么一个也不分配**

  - 在 wait 操作中，增加了一个“ AND” 条件，故称为 AND 同步，或称为同时 wait 操作 。

  ```
  Swait (S1,S2, …,Sn ) {
      while (true) {
          if ( S1 ≥ 1 and s2 ≥ 1 and...and Sn ≥ 1 ) {
              for ( = 1 ; i<=n; i++)
                   si = Si-1;
              break;
          else {
              某些资源不够时的处理；
          	进程进入第一个小于1的信号量的阻塞队列 ;
          	恢复PC寄存器为Swait开始时的状态；
          }
      }
  }
  
  ssignal (S1,S2,…,Sn) {
      for( i = 1; i<=n; i+)
      	si = Si+1;
      	//未通过检查（资源不够用）时的处理；
  	    //进程P进入某阻塞队列；
  	    //然后继续循环判断下一个进程
  
      }
  }
  ```

  ![](https://pic.imgdb.cn/item/661fa83b0ea9cb1403588eed.png)

  ![](https://pic.imgdb.cn/item/661fa84c0ea9cb1403590e7f.png)

#### 信号量集

在每次分配时，采用信号量集来控制，可以分配多个资源。

```
Swait (S1 , t1, d1, ..., Sn, tn, dn) {		(满足ti ≥ di)
	if (S1 ≥ t1 &....& Sn≥ tn)
		for( i = 1; i <= n; i++)
			si = si - di;
        else {
        Place the executing process in the waitingqueue of the first Si with si<ti and set itsprogramcounter to the beginning of theSwait operation。
        }
} // end of Swait

Ssignal (S1, d1, .…，Sn, dn) {
	for( i =1; i<=n; i++) {
		si= si+ di;
		Remove all the process waitingin the queue associated with siinto the ready queue
	}
}
```

- Si：i 类资源现有数量
- ti：i 类资源的分配下限值
- di：申请 i 类资源数量;

![](https://pic.imgdb.cn/item/661fac2b0ea9cb14037ae15c.png)

![](https://pic.imgdb.cn/item/661fac400ea9cb14037ba247.png)

- `Swait(S, d, d)`表示每次申请d个资源，当少于d个时，便不分配
- `Swait(S, 1, 1)`表示一般的互斥信号量（S=1时）或记录型信号量（S>1时）
- `Swait(S, 1, 0)`可作为一个可控开关（当S ≥ 1时，允许多个进程进入临界区；当S=0时，禁止任何进程进入临界区）

**利用信号量实现进程互斥**

为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量` mutex `，并设其初始值为 1 ，然后将各进程访问该资源的临界区 CS 置于` wait(mutex）`和` signal(mutex)`操作之间即可。

```
var  mutex：semaphore:=1；
  begin
      parbegin
        process1：begin
          repeat
              wait（mutex）；
              critical  section
              signal（mutex）；
              remainder  section
           until false;
          end
      process2：begin
         repeat
           wait（mutex）;
           critical  section
           signal（mutex）;
           remainder  section
          until false；
     end
  		parend 
```

> 注意：
>
> - `wait(mutex)`和` signal(mutex)`必须成对出现
> - 缺少` wait(mutex) `导致系统混乱，不能保证对临界资源的互斥访问
> - 缺少 `signal(mutex)`会使临界资源永远不释放等待该资源的进程不能被唤醒 

**利用信号量实现前趋关系**

![](https://pic.imgdb.cn/item/661fb2d20ea9cb1403b710ba.png)

#### 管程机制

一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能够同步进程和改变管程中的数据”。

管程由4部分组成：

- 管程的名字
- 局部于管程的 共享数据结构的说明
- 对该数据结构进行操作的一组过程
- 对局部于管程的数据设置初始值的语句 
  - 面向对象方法

**管程的主要特点**

- 局部数据变量只能被管程的过程访问，任何外部过程都不能访问。
- 一个进程通过调用管程的一个过程进入管程。
- 在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被挂起，以等待管程变成可用的。

### 经典进程同步问题

#### 生产者-消费者问题

生产者和消费者进程共享一个大小固定的缓冲池。生产者生产数据，并将生产的数据存入缓冲池；消费者从缓冲池中取数据 。

假设缓冲池的大小为 n 个缓冲区，缓冲池可以被生产者和消费者循环使用。

分别设置两个指针 in 和 out ，指向生产者 将要存放 数据的空缓冲区和 消费者 将要取走数据的缓冲区， 如图

![](https://pic.imgdb.cn/item/661fbe6d0ea9cb14032a9f4e.png)

必须使生产者和消费者*互斥进入缓冲区*。即，某时刻只允许一个实体（生产者或消费者）访问缓冲区，生产者互斥消费者和其它任何生产者。

生产者不能向满缓冲池写数据，消费者也不能在空缓冲池中取数据，即生产者与消费者必须*同步*。

![](https://pic.imgdb.cn/item/661fbef00ea9cb14032fbc6b.png)

**利用记录型信号量解决**

![](https://pic.imgdb.cn/item/661fbf880ea9cb1403363c7b.png)

![](https://pic.imgdb.cn/item/661fbf9e0ea9cb1403373362.png)

**利用AND型信号量解决**

![](https://pic.imgdb.cn/item/661fc0a10ea9cb14034230da.png)

![](https://pic.imgdb.cn/item/661fc0b10ea9cb140342e4dd.png)

> 在生产者—消费者问题中应注意：首先，在每个程序中用于实现互斥的wait(mutex)和signal(mutex)必须成对地出现；其次，对资源信号量empty和full的wait和signal操作，同样需要成对地出现，但它们分别处于不同的程序中。例如，wait(empty)在计算进程中，而signal(empty)则在打印进程中，计算进程若因执行wait(empty)而阻塞，则以后将由打印进程将它唤醒；最后，在每个程序中的多个wait 操作顺序不能颠倒，应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁。

#### 哲学家进餐问题

> 五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。
>
> 经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下：
>
> ```
>  Var chopstick: array［0, …, 4］ of semaphore;
> ```
>
> 当每个人都拿到一只筷子时发生死锁。

- 至多只允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。（记录型信号量）

  ```
  Semaphore chopstick[5]={1,1,1,1,1};
  Semaphore room=4;
  Void philosopher(int i)
  {
     while(true) {
          think();
          wait(room); //请求进入房间进餐
          wait(chopstick[i]);//请求左手边的筷子
          wait(chopstick[(i+1) %5]); //请求右手边的筷子
          eat();                               
          singal(chopstick[i]);// 释放左手边的筷子
          signal(chopstick[(i+1) %5]);//释放右手边的筷子
          singal(room);
      }
  }
  ```

- 利用AND型信号量机制

  在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的AND同步问题，故用AND信号量机制可获得最简洁的解法,**且可避免死锁**。

  ```
  Semaphore chopstick[5]={1,1,1,1,1};
  Void philosopher(int I)
  {
       while(true) {
          Think();
           Swait(chopstick[(I+1) %5]，chopstick[I]);
           eat();
          Ssignal(chopstick[(I+1) %5]，chopstick[I]);
       }
  } 
  ```

- 规定奇数号的哲学家先拿起他左边的筷子,然后再去拿他右边的筷子;而偶数号的哲学家则相反.按此规定,将是2,3号哲学家竞争3号筷子,4,5号哲学家竞争5号筷子.即三个哲学家都竞争奇数号筷子,获得后,再去竞争偶数号筷子,最后总会1个哲学家能获得两支筷子而进餐

  ```
  Semaphore chopstick[5]={1,1,1,1,1};
  void philosopher(int i)
  {
      While(true)
      {
          Think();
          If(i%2==0) //偶数号哲学家，先右后左
          {
              Wait(chopstick[(i+1)mod5]);
              Wait(chopstick[i]);
              eat(); 
              signal(chopstick [(i+1)mod5]);
              singal(chopstick[i]);
          }
          else //奇数号哲学家，先左后右
          {
              Wait(chopstick[i]);
              Wait (chopstick[(i+1)mod5]); 
              eat();
              signal(chopstick[i]);
              signal(chopstick[(i+1)mod5]); 
          }
  	}
  }
  
  
  ```

#### 读者/写者问题

若干读进程只能读数据，若干写进程只能写数据。

- 允许多个读者进程*可以同时读数据*；
- 不允许多个写者进程同时写数据，即*只能互斥写数据；*
- 若有写者进程正在写数据，则不允许读者进程读数据。

**利用记录型信号量解决**

规则：只要有一个Reader进程在读，便不允许Writer进程去写。

为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。

仅当Readcount=0, 表示尚无Reader进程在读时，Reader进程才需要执行Wait(Wmutex)操作。若wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。

同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才需执行signal(Wmutex)操作，以便让Writer进程写。

又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，应该为它设置一个互斥信号量rmutex。 

```
semaphore mutex = 1, wmutex  = 1
int readcount = 0
```

![](https://pic.imgdb.cn/item/661fc4ec0ea9cb1403702dfe.png)

**利用信号量集解决**

为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex，初始值为1。

设置一个资源信号量L，初始值为RN，代表最多允许RN个读进程同时进入临界区

![](https://pic.imgdb.cn/item/661fc5080ea9cb14037153fb.png)

### 线程的基本概念

- 进程：操作系统中拥有资源和独立运行的基本单位
- 进程的引入：实现单处理机环境下多程序并发的功能。
- 线程的引入：提高多处理机环境下程序的并发程度

进程的相关属性：

- 独立拥有资源，独立运行
- 运行包含创建、执行、撤销、切换等多个 阶段
- 各阶段必然有分配和释放资源的操作
- 这些操作在进程数量较多时影响系统性能

#### 线程的属性

- 线程是一个被调度和分派的 **基本单位** 并可**独立运行**的实体。
- 线程 是可以 **并发执行**
- **共享**进程资源
- 线程是轻型**实体**

#### 线程与进程的比较

![](https://pic.imgdb.cn/item/661fc8050ea9cb1403915ac0.png)

#### 线程的状态

- **线程控制块**（TCB）：保存线程状态参数
  - 寄存器状态
  - 堆栈
  - 线程运行状态
  - 优先级
  - 线程专有存储器
  - 信号屏蔽

- 线程的状态

  - 运行态
  - 就绪态
  - 阻塞态

  ![](https://pic.imgdb.cn/item/661fc9470ea9cb14039fc0d1.png)

#### 线程的创建与终止

##### 创建

创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个线程标识符供以后使用。

##### 终止

终止线程的方式有两种：

- 线程完成任务后自行退出
- 线程在运行出现错误退出或被其它线程终止运行

#### 多线程操作系统中的进程

- **作为系统资源分配的单位**

  进程为线程提供资源和运行环境，线程只能在进程的环境下运行

- **可包括多个线程**

  所有的线程都只能属于某一个特定进程

- **进程不是一个可执行的实体**

  进程中的线程才是可执行的实体。此时进程的“运行”态实际上是指进程中的某个线程正在运行

### 线程的实现

#### 线程的实现方式

- **内核支持线程**KST

  **优点**

  - 在多处理器系统中内核能够同时调度同一进程中多个线程并行执行
  -  如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程
  -  内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小
  -  内核本身也可以采用多线程技术 可以提高系统的执行速度和效率

  **缺点**

  对于用户的线程切换而言其模式切换的开销 较大 。在同一个进程中从一个线程切换到另一个线程时，需要从 **用户态转到内核态**进行 。这是因为用户进程的线程在用户态运行而线程调度和管理又是在内核实现的因此系统开销较大 。

- **用户级线程**ULT（User Level Threads）

  - 线程的创建 、 撤销 、 同步与通信无需内核支持
  - 用户级线程的切换常常发生在同一进程内部
  - 线程切换的规则较为简单 切换速度快
  - 线程控制块 TCB 设置在用户空间，内核不知道用户级线程的存在
  - 设置用户级线程的系统中，核心按**进程**为单位分配时间片

  **优点**

  - 线程切换不需要转换到内核空间
  - 调度算法可以是进程专用的
  - 用户级线程的实现与操作系统平台无关

  **缺点**

  - 系统调用阻塞问题
  - 在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点

- **组合方式**

  把用户级线程和内核支持线程两种方式进行组合，提供了组合方式 ULT/KST 线程

  - 内核支持多 KST 线程的建立、调度和管理
  - 同时 也允许用户应用程序建立、调度和管理用户级线程
  - 组合方式线程中，同一个进程内的多个线程可以同时在多处理器上并行执行，而且在阻塞一个线程时，并不需要将整个进程阻塞 

#### 线程的控制操作

![](https://pic.imgdb.cn/item/661fd0af0ea9cb1403fd8f98.png)

## 👮‍♂️ 处理机调度与死锁

- 高级调度

  调度对象： **作业**，又称作业调度、长程调度、接纳调度

  实现：作业管理程序

  将外存作业调入内存，创建 PCB 等，插入就绪队列。

  主要用于 **批处理** 系统。

- 中级调度

  又称 **内存** 调度

  对象：挂起的进程

  功能：把外存上那些已经具备运行条件的就绪进程重新载入内存。**从静止就绪到活动就绪**。

  实现：内存管理中的对换进程

  应用范围：具有对换功能的 操作系统

- 低级调度

  又称 **进程** 调度或短程调度

  对象：就绪进程（或内核线程）

  功能：决定就绪队列中的那个进程应获得处理机，并将处理机分配给选中的进程。

  实现者 ：分派程序（dispatcher）

  应用范围 ：主要用于 **交互式系统**

### 作业调度算法

周转时间=等待时间+服务时间

带权周转时间=周转时间/服务时间

#### FCFS 先来先服务算法

- 既可用于 **作业调度** ，也可用于 **进程调度** 
- 作业调度时，优先选择后备作业中最先进入队列的作业
- 进程调度时，每次调度从就绪队列中选择一个最先进入该队列的进程。
- 有利于长作业（长进程 ），而不利于短作业（短进程 ）

![](https://pic.imgdb.cn/item/6620878d0ea9cb1403a9e05b.png)

缺陷：对待短作业（进程）不公平，如果他们排在队列后面，则其等待时间远大于其执行时间。

#### SJF/SPF 短作业/进程优先

**短作业/进程优先调度算法 SJ(P)F** 是指对短作业或短进程优先调度的算法 。 它们可以分别用于作业调度和进程调度 。

- **短作业**优先的调度算法 是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行 。
- **短进程**优先调度算法 则是从就绪队列中选出一估计运行时间最短的进程 将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度 。

![](https://pic.imgdb.cn/item/6620893c0ea9cb1403b46950.png)

如果当前进程运行时间内有新的进程进入就绪队列且该进程的服务时间**小于**当前进程，则切换进程。

缺点：

- 该算法对长作业不利，如作业 C 的周转时间由 10 增至 16其带权周转时间由 2 增至 3.1 。甚至长作业长期得不到执行
- 不能保证紧迫性作业 进程 会被及时处理。
- 由于作业 进程 的长短只是根据用户所提供的估计执行时间而定的，而用户不一定对执行时间估计那么准确，致使该算法不一定能真正做到短作业优先调度。

#### 优先级调度算法 Priority scheduling algorithm, PSA

- 外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级。
- 选择优先级高 的作业（进程）投入 运行。
- 即可用于作业调度算法，也可用于进程调度。

#### 高响应比优先调度算法 Highest Response Ratio Next，HRRN

- 既考虑作业的等待时间，又考虑作业的运行时间

- 赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加

![](https://pic.imgdb.cn/item/66208b880ea9cb1403c2fe42.png)

等待时间 + 要求服务时间 = 响应时间
故优先级相当于响应比$ R_p$

![](https://pic.imgdb.cn/item/66208bc40ea9cb1403c4812e.png)

- 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。
- 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。
- 对于长作业，作业的优先级可以随等待时间的增加而提高，从而也可获得处理机。
- 简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序 ，避免长作业长期得不到服务。

### 进程调度的任务

- 选取合适的进程
- 保存现场
- 把处理器分配给要执行的进程

### 进程调度的机制

![](https://pic.imgdb.cn/item/66208f1a0ea9cb1403d9cce6.png)

### 进程调度的方式

- 非抢占式

  一旦进程投入运行，除了进程完成或者需要阻塞外，不能剥夺其处理机。

  采用这种方式时，引起调度的原因可归结为：

  - 进程运行完毕或因发生某事件而无法继续运行
  - 因 I/O 请求而阻塞
  - 因通信或者同步而阻塞

- 抢占方式

  允许系统根据某种原则，暂停正在执行的进程，重新分配处理机。
  使用抢占式的原因：

  - 批处理：防止长进程长期占用 CPU ，公平
  - 分时：人机交互
  - 实时：紧迫任务的执行

  主要原则

  - 优先权、短进程优先、时间片原则

### 轮转（RR）调度算法

- 分时系统的需求

- 每个进程仅运行一个时间片即被抢占 CPU

- 轮转算法原理

  FCFS策略 + 时钟中断 + 时间片 原则

- 进程切换时机

  - **时间片内进程结束** ，进程结束事件激活进程调度新进程可运行一个 时间片。
  - **时间片用完** ，时钟中断激活调度，旧进程到就绪队列尾，队头进程投入运行一个时间片。

- 时间片大小的确定

  - 太小：利于短作业，但增大调度和上下文切换频率增大系统开销；
  - 太长：退化为 FCFS 算法。
  - 合适：略大于一次典型的交互所需的时间，使大多数交互式进程能在一个时间片内完成。

> 每个进程运行一个时间片后不论是否完成都进入下一个进程的执行，且将自身置于队列末

![](https://pic.imgdb.cn/item/662094480ea9cb1403fae30c.png)

![](https://pic.imgdb.cn/item/662094730ea9cb1403fc0563.png)

### 多级反馈队列调度算法

#### **调度机制**

- 设置多个就绪队列 ，并为各个队列赋予不同的优先级。
- 优先级愈高 的队列的进程的执行 时间片就愈小 。
- 新进程首先进入最高优先级的队列。每个队列采用 FCFS算法。队列中的进程运行一个时间片后 未结束则降级 排到下一个队列的末尾。最低优先权队列中的进程则**按轮转方式**运行。
- 按 **队列优先级** 调度。只有比本队列的优先级高的队列均空时，才运行该队列中的进程。

![image-20240418114624959](D:\works\Class-Notes-4\操作系统\操作系统期中复习.assets\image-20240418114624959.png)











































